<<<<<<< HEAD
/*
rr_doc.c

!!! Achtung: Diese Datei enthält nur Kommentare !!!

Projekt hz-rr01x
Dokumentationsdatei

==============================================================================
history
==============================================================================
rev.
HZ-RR.012  29.11.2016  pl  first version sent out
HZ-RR011c  06.12.2016  pl +removed error in LED display after serial comm.
                          +command 0x3A: reset using watchdog added
                          +version in rr.h built from "HZ-RR" and "011c" string
HZ-RR011c  09.12.2016  pl  changes from Installation:
                          +set temperature (Soll-T.) is only ok for reg. 1!
                           others have 50.0degC constantly -> fixed
                          +p-factor ist too high, pFZu, pFAuf set to halve values
                          +change Kennlinie; p1=(75;50) -> P1=(75;47)
                          +factory reset of controller 4 works now
                          +any time the valve closes (0%) it should open for 4 sec
                           to let some water flow; getting real Ruecklauf temperatures 
HZ-RR012d  16.12.2016  pl -in rr_ser.c a strncpy() call cleared parameters unintendedly.
                           changed; check of version at upload omitted
                          -received string with parameters containx 0x00 bytes
                           removed
                          -tvz / tvzTValid  / tvzOk introduced; contains Vorlauf temperature
                           from Zentrale; tvzOk is counted down by heartbeat
                          -status request 0 returns firmware version, 1..4 unchanged
HZ-RR012d  20.02.2017  pl + chance factory set predefined values to actual values
                            from experience;                          

==============================================================================
lower level code was generated using Cube HAL-Library and CubeMX generator
from ST-Micro. The generator file is placed in .ioc file within the software
directory

Most of the application code is placed in rr-folders within source and include
directories
interrupt callback functions within the HAL system are defined weak and are 
handled in the rr source code if applicable

Some modifications have to be made within the HAL-generated code in their
typical user code area



----------------------------------------------------------------------




==============================================================================

1. Aufbau
=========
Jedes Modul besteht aus 4 Reglern und einer Ablaufsteuerung mit Kommunikation zu einem Master PC.

2. Funktion
===========


2.1. Modifikationen am CUBE System (HAL-Oberflaeche):
-----------------------------------------------------

2.1.1. jump to start of rr - main function
------------------------------------------
- Code of function "main.c" and HAL subsystem is copied from the ST-micro CUBE library
  and is partly generated by the CubeMX program generator.
- Application code is written in separate functions ans stored in files starting with "rr_"

To enable a proper interface to the application modules the generated function "main.c"
has to be extended. Find text within // ... //  ( originally /-star and star-/ )
and place the lines in between:

    // USER CODE BEGIN Includes //
    #include "rr.h"
    // USER CODE END Includes //

and:

    // USER CODE BEGIN 2 //
    rr();
    // USER CODE END 2 //


2.1.1. Heartbeat timer; 1msec
-----------------------------
DAtei "main.c" / Funktion "void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)"
einfuegen:
    // USER CODE BEGIN Callback 1 //
      if (htim->Instance == TIM2) {
        if(stat.tvzTOk > 0.0) {
          stat.tvzOk -= 0.001;
        }
      }
    // USER CODE END Callback 1 //

2.1.2. Serial receive characters of undefined count to a ring-buffer
--------------------------------------------------------------------
Changes are documented in the module rr_ser.c ;

2.2. Python Modul erzeugt C-Programme mit den Standard Parametern
-----------------------------------------------------------------
AUTOGENE
--------
Variable names and parameter values and limits are used in several parts of
the program, e.g. for input, check, set, transmit, receive
To avoid errors especially after changes a single data file has been set
"param11d.py" has been generated containing all necessary 
              parameters,
              variable names
              limits
              menue texts
This file is used by:
"rr_autogene.py"   to generate a c-source file "rr_autogene.c"
                   which has to be copied to the source folder of the hz_rr project
                   to be cross compiled for the modules
the Python "Zentrale" software for dialog between the modules and the central
                   computer, e.g. a Raspberry Pi 3.

2.2.1. procedure after changes to parameters:
---------------------------------------------
1. change parameters in the 
"param11d.py" file. Note "11d" means the current version. For later versions the
                    letter or the number will be increased
2. copy the file to the folder: "<module software project folder>/prog_tools_python/"
3. make sure that the file name is used by "rr_autogene.py" (not an older version)
4. the path to the actual project is set to the appropriate .c an .h application
   directories; make sure the path is ok - !!!!! version number may chane !!!!!
5. Build the new project and program the modules





3. Übertragunsprotokoll
=======================

3.1. Verbindungsstandards
-------------------------

     Hardwarelayer: RS-485; 
     Protokoll:     Modbus ASCII; 
     Abweichung:    Master - Slave Verfahren; 
                    die Regler sind slaves, 
                    der Master ist ein PC, z.B. Raspberry Pi 

3.2. Protokollaufbau
--------------------
3.2.1. Syntax:
--------------
Gemäss Modbus Standard: Jedes Datenpaket das über RS-485 übertragen wird hat die Form
":AABBd...dEE<cr><lf>" mit:

  :      start des Protokolls
  <AA>     Adresse 0x01..0x1E (1..30) des Moduls; über Steckbrücken gesetzt
           0x00 ist reserviert für broadcast Meldungen vom PC-Master an alle Slaves (ohne Antowrt)
           0xFF ist reserviert für den Master; ist eine feste Adresse
  <BB>     Funktion; siehe untenstehende Tabelle
  <d...d>  Daten, siehe unten stehende Tabelle
  <EE>     Paritätsdatenwort wie in Modbus Definition gefordert (ohne 1. Byte ':')
  <cr>     Carriage Return = 0x0D = 13d, Steuerzeichen für Wagenrücklauf
  <lf>     Line Feed = 0x0A = 10d, Steuerzeichen für Neue Zeile

3.2.2. Fuktionen  <BB>
0x00
0x01   Bereitschafts Abfrage an das Modul mit der Adresse <AA>:
       Master an Slave:    ":<AA>010<CS><EE><cr><lf>"
       Antwort an Master:  ":FF010ACK<CS><EE><cr><lf>"   falls Modul bereit ist
                           ":FF010NAK<CS><EE><cr><lf>"  falls Modul nicht bereit ist
                           keine Antwort: timeout nach 0.2 sekunden
0x02   Status 1 Abfrage an Regler r im Modul mit der Adresse <AA>:
       (elementare Status Informationen)   
       Master an Slave:    ":<AA>02r<CS><EE><cr><lf>", r e {1..4}
       Antwort an Master:  ":FF02r<daten><CS><EE><cr><lf>          falls status daten vorhanden
                           ":FF02rNotActive<CS><EE><cr><lf>        falls Regler nicht aktiv
0x03   Status 2 Abfrage an Regler r im Modul mit der adresse <AA>:
       (zusätzliche Staus Informationen)
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
...

3.2.3. Daten <d...d>
Der Dateninhalt ist von der jeweiligen Funktion und der Übertragungsrichtung abhängig.
Byte         Inhalt
  1          0 = Daten für Modul; 1,2,3,4 = Daten für Regler 1,2,3,4
  2..n       Datenbytes je nach Funktion
  n+1..n+4   <CS>  4 Zeichen für eine 2-Byte checksum im HEX-Format;
                   = Summe aller Bytes nach ':' bis n. Datenbyte



Dateninhalt:




=======
/*
rr_doc.c

!!! Achtung: Diese Datei enthält nur Kommentare !!!

Projekt hz-rr01x
Dokumentationsdatei

==============================================================================
history
==============================================================================
rev.
HZ-RR.012  29.11.2016  pl  first version sent out
HZ-RR011c  06.12.2016  pl +removed error in LED display after serial comm.
                          +command 0x3A: reset using watchdog added
                          +version in rr.h built from "HZ-RR" and "011c" string
HZ-RR011c  09.12.2016  pl  changes from Installation:
                          +set temperature (Soll-T.) is only ok for reg. 1!
                           others have 50.0degC constantly -> fixed
                          +p-factor ist too high, pFZu, pFAuf set to halve values
                          +change Kennlinie; p1=(75;50) -> P1=(75;47)
                          +factory reset of controller 4 works now
                          +any time the valve closes (0%) it should open for 4 sec
                           to let some water flow; getting real Ruecklauf temperatures 
HZ-RR012d  16.12.2016  pl -in rr_ser.c a strncpy() call cleared parameters unintendedly.
                           changed; check of version at upload omitted
                          -received string with parameters containx 0x00 bytes
                           removed
                          -tvz / tvzTValid  / tvzOk introduced; contains Vorlauf temperature
                           from Zentrale; tvzOk is counted down by heartbeat
                          -status request 0 returns firmware version, 1..4 unchanged
HZ-RR012d  20.02.2017  pl + chance factory set predefined values to actual values
                            from experience;                          

==============================================================================
lower level code was generated using Cube HAL-Library and CubeMX generator
from ST-Micro. The generator file is placed in .ioc file within the software
directory

Most of the application code is placed in rr-folders within source and include
directories
interrupt callback functions within the HAL system are defined weak and are 
handled in the rr source code if applicable

Some modifications have to be made within the HAL-generated code in their
typical user code area



----------------------------------------------------------------------




==============================================================================

1. Aufbau
=========
Jedes Modul besteht aus 4 Reglern und einer Ablaufsteuerung mit Kommunikation zu einem Master PC.

2. Funktion
===========


2.1. Modifikationen am CUBE System (HAL-Oberflaeche):
-----------------------------------------------------

2.1.1. jump to start of rr - main function
------------------------------------------
- Code of function "main.c" and HAL subsystem is copied from the ST-micro CUBE library
  and is partly generated by the CubeMX program generator.
- Application code is written in separate functions ans stored in files starting with "rr_"

To enable a proper interface to the application modules the generated function "main.c"
has to be extended. Find text within // ... //  ( originally /-star and star-/ )
and place the lines in between:

    // USER CODE BEGIN Includes //
    #include "rr.h"
    // USER CODE END Includes //

and:

    // USER CODE BEGIN 2 //
    rr();
    // USER CODE END 2 //


2.1.1. Heartbeat timer; 1msec
-----------------------------
DAtei "main.c" / Funktion "void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)"
einfuegen:
    // USER CODE BEGIN Callback 1 //
      if (htim->Instance == TIM2) {
        if(stat.tvzTOk > 0.0) {
          stat.tvzOk -= 0.001;
        }
      }
    // USER CODE END Callback 1 //

2.1.2. Serial receive characters of undefined count to a ring-buffer
--------------------------------------------------------------------
Changes are documented in the module rr_ser.c ;

2.2. Python Modul erzeugt C-Programme mit den Standard Parametern
-----------------------------------------------------------------
AUTOGENE
--------
Variable names and parameter values and limits are used in several parts of
the program, e.g. for input, check, set, transmit, receive
To avoid errors especially after changes a single data file has been set
"param11d.py" has been generated containing all necessary 
              parameters,
              variable names
              limits
              menue texts
This file is used by:
"rr_autogene.py"   to generate a c-source file "rr_autogene.c"
                   which has to be copied to the source folder of the hz_rr project
                   to be cross compiled for the modules
the Python "Zentrale" software for dialog between the modules and the central
                   computer, e.g. a Raspberry Pi 3.

2.2.1. procedure after changes to parameters:
---------------------------------------------
1. change parameters in the 
"param11d.py" file. Note "11d" means the current version. For later versions the
                    letter or the number will be increased
2. copy the file to the folder: "<module software project folder>/prog_tools_python/"
3. make sure that the file name is used by "rr_autogene.py" (not an older version)
4. the path to the actual project is set to the appropriate .c an .h application
   directories; make sure the path is ok - !!!!! version number may chane !!!!!
5. Build the new project and program the modules





3. Übertragunsprotokoll
=======================

3.1. Verbindungsstandards
-------------------------

     Hardwarelayer: RS-485; 
     Protokoll:     Modbus ASCII; 
     Abweichung:    Master - Slave Verfahren; 
                    die Regler sind slaves, 
                    der Master ist ein PC, z.B. Raspberry Pi 

3.2. Protokollaufbau
--------------------
3.2.1. Syntax:
--------------
Gemäss Modbus Standard: Jedes Datenpaket das über RS-485 übertragen wird hat die Form
":AABBd...dEE<cr><lf>" mit:

  :      start des Protokolls
  <AA>     Adresse 0x01..0x1E (1..30) des Moduls; über Steckbrücken gesetzt
           0x00 ist reserviert für broadcast Meldungen vom PC-Master an alle Slaves (ohne Antowrt)
           0xFF ist reserviert für den Master; ist eine feste Adresse
  <BB>     Funktion; siehe untenstehende Tabelle
  <d...d>  Daten, siehe unten stehende Tabelle
  <EE>     Paritätsdatenwort wie in Modbus Definition gefordert (ohne 1. Byte ':')
  <cr>     Carriage Return = 0x0D = 13d, Steuerzeichen für Wagenrücklauf
  <lf>     Line Feed = 0x0A = 10d, Steuerzeichen für Neue Zeile

3.2.2. Fuktionen  <BB>
0x00
0x01   Bereitschafts Abfrage an das Modul mit der Adresse <AA>:
       Master an Slave:    ":<AA>010<CS><EE><cr><lf>"
       Antwort an Master:  ":FF010ACK<CS><EE><cr><lf>"   falls Modul bereit ist
                           ":FF010NAK<CS><EE><cr><lf>"  falls Modul nicht bereit ist
                           keine Antwort: timeout nach 0.2 sekunden
0x02   Status 1 Abfrage an Regler r im Modul mit der Adresse <AA>:
       (elementare Status Informationen)   
       Master an Slave:    ":<AA>02r<CS><EE><cr><lf>", r e {1..4}
       Antwort an Master:  ":FF02r<daten><CS><EE><cr><lf>          falls status daten vorhanden
                           ":FF02rNotActive<CS><EE><cr><lf>        falls Regler nicht aktiv
0x03   Status 2 Abfrage an Regler r im Modul mit der adresse <AA>:
       (zusätzliche Staus Informationen)
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
...

3.2.3. Daten <d...d>
Der Dateninhalt ist von der jeweiligen Funktion und der Übertragungsrichtung abhängig.
Byte         Inhalt
  1          0 = Daten für Modul; 1,2,3,4 = Daten für Regler 1,2,3,4
  2..n       Datenbytes je nach Funktion
  n+1..n+4   <CS>  4 Zeichen für eine 2-Byte checksum im HEX-Format;
                   = Summe aller Bytes nach ':' bis n. Datenbyte



Dateninhalt:




>>>>>>> fdb118d65f9ba2384457aa1ceb71ee94c0edf102
*/